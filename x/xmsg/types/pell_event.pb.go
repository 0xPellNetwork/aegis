// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: xmsg/pell_event.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// / @notice Emitted when @param staker deposit @param shares of @param token to
// / @param strategy. event Deposit(address staker, IERC20 token, IStrategy
// / strategy, uint256 shares);
type StakerDeposited struct {
	Staker   string                 `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	Token    string                 `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Strategy string                 `protobuf:"bytes,3,opt,name=strategy,proto3" json:"strategy,omitempty"`
	Shares   cosmossdk_io_math.Uint `protobuf:"bytes,4,opt,name=shares,proto3,customtype=cosmossdk.io/math.Uint" json:"shares"`
}

func (m *StakerDeposited) Reset()         { *m = StakerDeposited{} }
func (m *StakerDeposited) String() string { return proto.CompactTextString(m) }
func (*StakerDeposited) ProtoMessage()    {}
func (*StakerDeposited) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{0}
}
func (m *StakerDeposited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakerDeposited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakerDeposited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakerDeposited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakerDeposited.Merge(m, src)
}
func (m *StakerDeposited) XXX_Size() int {
	return m.Size()
}
func (m *StakerDeposited) XXX_DiscardUnknown() {
	xxx_messageInfo_StakerDeposited.DiscardUnknown(m)
}

var xxx_messageInfo_StakerDeposited proto.InternalMessageInfo

func (m *StakerDeposited) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *StakerDeposited) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *StakerDeposited) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

// / @notice Emitted when @param staker delegates to @param operator.
// / event StakerDelegated(address indexed staker, address indexed operator);
type StakerDelegated struct {
	Staker   string `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *StakerDelegated) Reset()         { *m = StakerDelegated{} }
func (m *StakerDelegated) String() string { return proto.CompactTextString(m) }
func (*StakerDelegated) ProtoMessage()    {}
func (*StakerDelegated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{1}
}
func (m *StakerDelegated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakerDelegated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakerDelegated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakerDelegated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakerDelegated.Merge(m, src)
}
func (m *StakerDelegated) XXX_Size() int {
	return m.Size()
}
func (m *StakerDelegated) XXX_DiscardUnknown() {
	xxx_messageInfo_StakerDelegated.DiscardUnknown(m)
}

var xxx_messageInfo_StakerDelegated proto.InternalMessageInfo

func (m *StakerDelegated) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *StakerDelegated) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// Withdrawal message
type Withdrawal struct {
	Staker         string   `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	DelegatedTo    string   `protobuf:"bytes,2,opt,name=delegated_to,json=delegatedTo,proto3" json:"delegated_to,omitempty"`
	Withdrawer     string   `protobuf:"bytes,3,opt,name=withdrawer,proto3" json:"withdrawer,omitempty"`
	Nonce          string   `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	StartTimestamp uint32   `protobuf:"varint,5,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	Strategies     []string `protobuf:"bytes,6,rep,name=strategies,proto3" json:"strategies,omitempty"`
	Shares         []string `protobuf:"bytes,7,rep,name=shares,proto3" json:"shares,omitempty"`
}

func (m *Withdrawal) Reset()         { *m = Withdrawal{} }
func (m *Withdrawal) String() string { return proto.CompactTextString(m) }
func (*Withdrawal) ProtoMessage()    {}
func (*Withdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{2}
}
func (m *Withdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Withdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Withdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Withdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Withdrawal.Merge(m, src)
}
func (m *Withdrawal) XXX_Size() int {
	return m.Size()
}
func (m *Withdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_Withdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_Withdrawal proto.InternalMessageInfo

func (m *Withdrawal) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *Withdrawal) GetDelegatedTo() string {
	if m != nil {
		return m.DelegatedTo
	}
	return ""
}

func (m *Withdrawal) GetWithdrawer() string {
	if m != nil {
		return m.Withdrawer
	}
	return ""
}

func (m *Withdrawal) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *Withdrawal) GetStartTimestamp() uint32 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *Withdrawal) GetStrategies() []string {
	if m != nil {
		return m.Strategies
	}
	return nil
}

func (m *Withdrawal) GetShares() []string {
	if m != nil {
		return m.Shares
	}
	return nil
}

// / event WithdrawalQueued(bytes32 withdrawalRoot, Withdrawal withdrawal);
type WithdrawalQueued struct {
	WithdrawalRoot []byte      `protobuf:"bytes,1,opt,name=withdrawal_root,json=withdrawalRoot,proto3" json:"withdrawal_root,omitempty"`
	Withdrawal     *Withdrawal `protobuf:"bytes,2,opt,name=withdrawal,proto3" json:"withdrawal,omitempty"`
}

func (m *WithdrawalQueued) Reset()         { *m = WithdrawalQueued{} }
func (m *WithdrawalQueued) String() string { return proto.CompactTextString(m) }
func (*WithdrawalQueued) ProtoMessage()    {}
func (*WithdrawalQueued) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{3}
}
func (m *WithdrawalQueued) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawalQueued) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawalQueued.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawalQueued) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawalQueued.Merge(m, src)
}
func (m *WithdrawalQueued) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawalQueued) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawalQueued.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawalQueued proto.InternalMessageInfo

func (m *WithdrawalQueued) GetWithdrawalRoot() []byte {
	if m != nil {
		return m.WithdrawalRoot
	}
	return nil
}

func (m *WithdrawalQueued) GetWithdrawal() *Withdrawal {
	if m != nil {
		return m.Withdrawal
	}
	return nil
}

// / @notice Emitted when @param staker undelegates from @param operator.
// / event StakerUndelegated(address indexed staker, address indexed operator)
type StakerUndelegated struct {
	Staker   string `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *StakerUndelegated) Reset()         { *m = StakerUndelegated{} }
func (m *StakerUndelegated) String() string { return proto.CompactTextString(m) }
func (*StakerUndelegated) ProtoMessage()    {}
func (*StakerUndelegated) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{4}
}
func (m *StakerUndelegated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakerUndelegated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakerUndelegated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakerUndelegated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakerUndelegated.Merge(m, src)
}
func (m *StakerUndelegated) XXX_Size() int {
	return m.Size()
}
func (m *StakerUndelegated) XXX_DiscardUnknown() {
	xxx_messageInfo_StakerUndelegated.DiscardUnknown(m)
}

var xxx_messageInfo_StakerUndelegated proto.InternalMessageInfo

func (m *StakerUndelegated) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *StakerUndelegated) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// / @notice Emitted when @param pellTxSenderAddress sent to @param
// / destinationAddress of @param destinationChainId. event PellSent(
// /    address sourceTxOriginAddress,
// /    address indexed pellTxSenderAddress,
// /    uint256 indexed destinationChainId,
// /    bytes destinationAddress,
// /    bytes message,
// /    bytes pellParams
// /  );
type PellSent struct {
	TxOrigin            string                 `protobuf:"bytes,1,opt,name=tx_origin,json=txOrigin,proto3" json:"tx_origin,omitempty"`
	Sender              string                 `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	ReceiverChainId     int64                  `protobuf:"varint,3,opt,name=receiver_chain_id,json=receiverChainId,proto3" json:"receiver_chain_id,omitempty"`
	Receiver            string                 `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Message             string                 `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	PellParams          string                 `protobuf:"bytes,6,opt,name=pell_params,json=pellParams,proto3" json:"pell_params,omitempty"`
	PellValue           cosmossdk_io_math.Uint `protobuf:"bytes,7,opt,name=pell_value,json=pellValue,proto3,customtype=cosmossdk.io/math.Uint" json:"pell_value"`
	DestinationGasLimit cosmossdk_io_math.Uint `protobuf:"bytes,8,opt,name=destination_gas_limit,json=destinationGasLimit,proto3,customtype=cosmossdk.io/math.Uint" json:"destination_gas_limit"`
}

func (m *PellSent) Reset()         { *m = PellSent{} }
func (m *PellSent) String() string { return proto.CompactTextString(m) }
func (*PellSent) ProtoMessage()    {}
func (*PellSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{5}
}
func (m *PellSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PellSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PellSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PellSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PellSent.Merge(m, src)
}
func (m *PellSent) XXX_Size() int {
	return m.Size()
}
func (m *PellSent) XXX_DiscardUnknown() {
	xxx_messageInfo_PellSent.DiscardUnknown(m)
}

var xxx_messageInfo_PellSent proto.InternalMessageInfo

func (m *PellSent) GetTxOrigin() string {
	if m != nil {
		return m.TxOrigin
	}
	return ""
}

func (m *PellSent) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *PellSent) GetReceiverChainId() int64 {
	if m != nil {
		return m.ReceiverChainId
	}
	return 0
}

func (m *PellSent) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *PellSent) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PellSent) GetPellParams() string {
	if m != nil {
		return m.PellParams
	}
	return ""
}

// inboound pell event
type InboundPellEvent struct {
	// oneof pell_data
	//
	// Types that are valid to be assigned to PellData:
	//
	//	*InboundPellEvent_StakerDeposited
	//	*InboundPellEvent_StakerDelegated
	//	*InboundPellEvent_PellSent
	//	*InboundPellEvent_WithdrawalQueued
	//	*InboundPellEvent_StakerUndelegated
	//	*InboundPellEvent_RegisterChainDvsToPell
	PellData isInboundPellEvent_PellData `protobuf_oneof:"pell_data"`
}

func (m *InboundPellEvent) Reset()         { *m = InboundPellEvent{} }
func (m *InboundPellEvent) String() string { return proto.CompactTextString(m) }
func (*InboundPellEvent) ProtoMessage()    {}
func (*InboundPellEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{6}
}
func (m *InboundPellEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InboundPellEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InboundPellEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InboundPellEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InboundPellEvent.Merge(m, src)
}
func (m *InboundPellEvent) XXX_Size() int {
	return m.Size()
}
func (m *InboundPellEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_InboundPellEvent.DiscardUnknown(m)
}

var xxx_messageInfo_InboundPellEvent proto.InternalMessageInfo

type isInboundPellEvent_PellData interface {
	isInboundPellEvent_PellData()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InboundPellEvent_StakerDeposited struct {
	StakerDeposited *StakerDeposited `protobuf:"bytes,1,opt,name=staker_deposited,json=stakerDeposited,proto3,oneof" json:"staker_deposited,omitempty"`
}
type InboundPellEvent_StakerDelegated struct {
	StakerDelegated *StakerDelegated `protobuf:"bytes,2,opt,name=staker_delegated,json=stakerDelegated,proto3,oneof" json:"staker_delegated,omitempty"`
}
type InboundPellEvent_PellSent struct {
	PellSent *PellSent `protobuf:"bytes,3,opt,name=pell_sent,json=pellSent,proto3,oneof" json:"pell_sent,omitempty"`
}
type InboundPellEvent_WithdrawalQueued struct {
	WithdrawalQueued *WithdrawalQueued `protobuf:"bytes,4,opt,name=withdrawal_queued,json=withdrawalQueued,proto3,oneof" json:"withdrawal_queued,omitempty"`
}
type InboundPellEvent_StakerUndelegated struct {
	StakerUndelegated *StakerUndelegated `protobuf:"bytes,5,opt,name=staker_undelegated,json=stakerUndelegated,proto3,oneof" json:"staker_undelegated,omitempty"`
}
type InboundPellEvent_RegisterChainDvsToPell struct {
	RegisterChainDvsToPell *RegisterChainDVSToPell `protobuf:"bytes,6,opt,name=register_chain_dvs_to_pell,json=registerChainDvsToPell,proto3,oneof" json:"register_chain_dvs_to_pell,omitempty"`
}

func (*InboundPellEvent_StakerDeposited) isInboundPellEvent_PellData()        {}
func (*InboundPellEvent_StakerDelegated) isInboundPellEvent_PellData()        {}
func (*InboundPellEvent_PellSent) isInboundPellEvent_PellData()               {}
func (*InboundPellEvent_WithdrawalQueued) isInboundPellEvent_PellData()       {}
func (*InboundPellEvent_StakerUndelegated) isInboundPellEvent_PellData()      {}
func (*InboundPellEvent_RegisterChainDvsToPell) isInboundPellEvent_PellData() {}

func (m *InboundPellEvent) GetPellData() isInboundPellEvent_PellData {
	if m != nil {
		return m.PellData
	}
	return nil
}

func (m *InboundPellEvent) GetStakerDeposited() *StakerDeposited {
	if x, ok := m.GetPellData().(*InboundPellEvent_StakerDeposited); ok {
		return x.StakerDeposited
	}
	return nil
}

func (m *InboundPellEvent) GetStakerDelegated() *StakerDelegated {
	if x, ok := m.GetPellData().(*InboundPellEvent_StakerDelegated); ok {
		return x.StakerDelegated
	}
	return nil
}

func (m *InboundPellEvent) GetPellSent() *PellSent {
	if x, ok := m.GetPellData().(*InboundPellEvent_PellSent); ok {
		return x.PellSent
	}
	return nil
}

func (m *InboundPellEvent) GetWithdrawalQueued() *WithdrawalQueued {
	if x, ok := m.GetPellData().(*InboundPellEvent_WithdrawalQueued); ok {
		return x.WithdrawalQueued
	}
	return nil
}

func (m *InboundPellEvent) GetStakerUndelegated() *StakerUndelegated {
	if x, ok := m.GetPellData().(*InboundPellEvent_StakerUndelegated); ok {
		return x.StakerUndelegated
	}
	return nil
}

func (m *InboundPellEvent) GetRegisterChainDvsToPell() *RegisterChainDVSToPell {
	if x, ok := m.GetPellData().(*InboundPellEvent_RegisterChainDvsToPell); ok {
		return x.RegisterChainDvsToPell
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InboundPellEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InboundPellEvent_StakerDeposited)(nil),
		(*InboundPellEvent_StakerDelegated)(nil),
		(*InboundPellEvent_PellSent)(nil),
		(*InboundPellEvent_WithdrawalQueued)(nil),
		(*InboundPellEvent_StakerUndelegated)(nil),
		(*InboundPellEvent_RegisterChainDvsToPell)(nil),
	}
}

// RegisterChainDVSToPell is a message to register a coordinator to Pell
type RegisterChainDVSToPell struct {
	ChainId                   uint64                      `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	RegistryRouterOnPell      string                      `protobuf:"bytes,2,opt,name=registry_router_on_pell,json=registryRouterOnPell,proto3" json:"registry_router_on_pell,omitempty"`
	CentralScheduler          string                      `protobuf:"bytes,3,opt,name=central_scheduler,json=centralScheduler,proto3" json:"central_scheduler,omitempty"`
	DvsChainApproverSignature *SignatureWithSaltAndExpiry `protobuf:"bytes,4,opt,name=dvs_chain_approver_signature,json=dvsChainApproverSignature,proto3" json:"dvs_chain_approver_signature,omitempty"`
	EjectionManager           string                      `protobuf:"bytes,5,opt,name=ejection_manager,json=ejectionManager,proto3" json:"ejection_manager,omitempty"`
	StakeManager              string                      `protobuf:"bytes,6,opt,name=stake_manager,json=stakeManager,proto3" json:"stake_manager,omitempty"`
}

func (m *RegisterChainDVSToPell) Reset()         { *m = RegisterChainDVSToPell{} }
func (m *RegisterChainDVSToPell) String() string { return proto.CompactTextString(m) }
func (*RegisterChainDVSToPell) ProtoMessage()    {}
func (*RegisterChainDVSToPell) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{7}
}
func (m *RegisterChainDVSToPell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterChainDVSToPell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterChainDVSToPell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterChainDVSToPell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterChainDVSToPell.Merge(m, src)
}
func (m *RegisterChainDVSToPell) XXX_Size() int {
	return m.Size()
}
func (m *RegisterChainDVSToPell) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterChainDVSToPell.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterChainDVSToPell proto.InternalMessageInfo

func (m *RegisterChainDVSToPell) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *RegisterChainDVSToPell) GetRegistryRouterOnPell() string {
	if m != nil {
		return m.RegistryRouterOnPell
	}
	return ""
}

func (m *RegisterChainDVSToPell) GetCentralScheduler() string {
	if m != nil {
		return m.CentralScheduler
	}
	return ""
}

func (m *RegisterChainDVSToPell) GetDvsChainApproverSignature() *SignatureWithSaltAndExpiry {
	if m != nil {
		return m.DvsChainApproverSignature
	}
	return nil
}

func (m *RegisterChainDVSToPell) GetEjectionManager() string {
	if m != nil {
		return m.EjectionManager
	}
	return ""
}

func (m *RegisterChainDVSToPell) GetStakeManager() string {
	if m != nil {
		return m.StakeManager
	}
	return ""
}

// SignatureWithSaltAndExpiry is a message to hold a signature with salt and
// expiry
type SignatureWithSaltAndExpiry struct {
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Salt      []byte `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
	Expiry    uint64 `protobuf:"varint,3,opt,name=expiry,proto3" json:"expiry,omitempty"`
}

func (m *SignatureWithSaltAndExpiry) Reset()         { *m = SignatureWithSaltAndExpiry{} }
func (m *SignatureWithSaltAndExpiry) String() string { return proto.CompactTextString(m) }
func (*SignatureWithSaltAndExpiry) ProtoMessage()    {}
func (*SignatureWithSaltAndExpiry) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08650de652ab101, []int{8}
}
func (m *SignatureWithSaltAndExpiry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureWithSaltAndExpiry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureWithSaltAndExpiry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureWithSaltAndExpiry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureWithSaltAndExpiry.Merge(m, src)
}
func (m *SignatureWithSaltAndExpiry) XXX_Size() int {
	return m.Size()
}
func (m *SignatureWithSaltAndExpiry) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureWithSaltAndExpiry.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureWithSaltAndExpiry proto.InternalMessageInfo

func (m *SignatureWithSaltAndExpiry) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignatureWithSaltAndExpiry) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *SignatureWithSaltAndExpiry) GetExpiry() uint64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func init() {
	proto.RegisterType((*StakerDeposited)(nil), "xmsg.StakerDeposited")
	proto.RegisterType((*StakerDelegated)(nil), "xmsg.StakerDelegated")
	proto.RegisterType((*Withdrawal)(nil), "xmsg.Withdrawal")
	proto.RegisterType((*WithdrawalQueued)(nil), "xmsg.WithdrawalQueued")
	proto.RegisterType((*StakerUndelegated)(nil), "xmsg.StakerUndelegated")
	proto.RegisterType((*PellSent)(nil), "xmsg.PellSent")
	proto.RegisterType((*InboundPellEvent)(nil), "xmsg.InboundPellEvent")
	proto.RegisterType((*RegisterChainDVSToPell)(nil), "xmsg.RegisterChainDVSToPell")
	proto.RegisterType((*SignatureWithSaltAndExpiry)(nil), "xmsg.SignatureWithSaltAndExpiry")
}

func init() { proto.RegisterFile("xmsg/pell_event.proto", fileDescriptor_c08650de652ab101) }

var fileDescriptor_c08650de652ab101 = []byte{
	// 952 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xb6, 0x13, 0x37, 0xb1, 0x9f, 0xd3, 0xd8, 0x1e, 0x12, 0xd7, 0x35, 0x91, 0x13, 0xcc, 0x81,
	0x42, 0x85, 0x5d, 0x19, 0xc1, 0x8d, 0x43, 0x43, 0xad, 0xba, 0x12, 0xd0, 0x32, 0x4e, 0x8b, 0xd4,
	0xcb, 0x6a, 0xe2, 0x7d, 0xac, 0x97, 0xec, 0xce, 0x2c, 0x33, 0xe3, 0x1f, 0xf9, 0x2f, 0x90, 0xf8,
	0x93, 0xb8, 0x54, 0x9c, 0x7a, 0x41, 0x42, 0x1c, 0x22, 0x94, 0xfc, 0x23, 0x68, 0x66, 0x67, 0xd7,
	0xc6, 0x50, 0x54, 0xa9, 0x37, 0xbf, 0xef, 0xcd, 0x7c, 0x7e, 0xef, 0x7d, 0xdf, 0x9b, 0x85, 0xc3,
	0x65, 0xac, 0x82, 0x7e, 0x82, 0x51, 0xe4, 0xe1, 0x1c, 0xb9, 0xee, 0x25, 0x52, 0x68, 0x41, 0x4a,
	0x06, 0x6e, 0x1f, 0x04, 0x22, 0x10, 0x16, 0xe8, 0x9b, 0x5f, 0x69, 0xae, 0xfb, 0x4b, 0x11, 0x6a,
	0x63, 0xcd, 0x2e, 0x50, 0x3e, 0xc2, 0x44, 0xa8, 0x50, 0xa3, 0x4f, 0x9a, 0xb0, 0xa3, 0x2c, 0xd4,
	0x2a, 0x9e, 0x14, 0xef, 0x55, 0xa8, 0x8b, 0xc8, 0x01, 0xdc, 0xd2, 0xe2, 0x02, 0x79, 0x6b, 0xcb,
	0xc2, 0x69, 0x40, 0xda, 0x50, 0x56, 0x5a, 0x32, 0x8d, 0xc1, 0x65, 0x6b, 0xdb, 0x26, 0xf2, 0x98,
	0x7c, 0x01, 0x3b, 0x6a, 0xca, 0x24, 0xaa, 0x56, 0xc9, 0x64, 0x4e, 0x3b, 0xaf, 0xae, 0x8e, 0x0b,
	0x7f, 0x5e, 0x1d, 0x37, 0x27, 0x42, 0xc5, 0x42, 0x29, 0xff, 0xa2, 0x17, 0x8a, 0x7e, 0xcc, 0xf4,
	0xb4, 0xf7, 0x3c, 0xe4, 0x9a, 0xba, 0xd3, 0xdd, 0xe1, 0xaa, 0xa8, 0x08, 0x03, 0xf6, 0x7f, 0x45,
	0xb5, 0xa1, 0x2c, 0x12, 0x94, 0x4c, 0x0b, 0xe9, 0xea, 0xca, 0xe3, 0xee, 0x55, 0x11, 0xe0, 0xfb,
	0x50, 0x4f, 0x7d, 0xc9, 0x16, 0x2c, 0x7a, 0x23, 0xc5, 0x07, 0xb0, 0xe7, 0x67, 0xff, 0xe3, 0x69,
	0xe1, 0x68, 0xaa, 0x39, 0x76, 0x26, 0x48, 0x07, 0x60, 0xe1, 0x88, 0x50, 0xba, 0x36, 0xd7, 0x10,
	0x33, 0x1a, 0x2e, 0xf8, 0x04, 0xd3, 0x3e, 0x69, 0x1a, 0x90, 0x8f, 0xa0, 0xa6, 0x34, 0x93, 0xda,
	0xd3, 0x61, 0x8c, 0x4a, 0xb3, 0x38, 0x69, 0xdd, 0x3a, 0x29, 0xde, 0xbb, 0x4d, 0xf7, 0x2d, 0x7c,
	0x96, 0xa1, 0x86, 0xde, 0xcd, 0x2c, 0x44, 0xd5, 0xda, 0x39, 0xd9, 0x36, 0xf4, 0x2b, 0xc4, 0x56,
	0x9e, 0xce, 0x71, 0xd7, 0xe6, 0xb2, 0x39, 0xc5, 0x50, 0x5f, 0xf5, 0xf7, 0xdd, 0x0c, 0x67, 0xe8,
	0x9b, 0x3f, 0x5d, 0xe4, 0x98, 0x27, 0x85, 0xd0, 0xb6, 0xdd, 0x3d, 0xba, 0xbf, 0x82, 0xa9, 0x10,
	0x9a, 0x3c, 0x58, 0xf5, 0xc4, 0x22, 0xdb, 0x74, 0x75, 0x50, 0xef, 0x19, 0xaf, 0xf4, 0x56, 0xa4,
	0x74, 0xed, 0x4c, 0xf7, 0x31, 0x34, 0x52, 0x59, 0x9e, 0x73, 0xff, 0x9d, 0x84, 0xf9, 0x7d, 0x0b,
	0xca, 0xcf, 0x30, 0x8a, 0xc6, 0xc8, 0x35, 0x79, 0x1f, 0x2a, 0x7a, 0xe9, 0x09, 0x19, 0x06, 0x21,
	0x77, 0x1c, 0x65, 0xbd, 0x7c, 0x6a, 0x63, 0xcb, 0x8e, 0xdc, 0xc7, 0x8c, 0xc3, 0x45, 0xe4, 0x13,
	0x68, 0x48, 0x9c, 0x60, 0x38, 0x47, 0xe9, 0x4d, 0xa6, 0x2c, 0xe4, 0x5e, 0xe8, 0x5b, 0x5d, 0xb6,
	0x69, 0x2d, 0x4b, 0x7c, 0x65, 0xf0, 0x27, 0xbe, 0xa9, 0x24, 0x83, 0x9c, 0x3e, 0x79, 0x4c, 0x5a,
	0xb0, 0x1b, 0xa3, 0x52, 0x2c, 0x40, 0x2b, 0x4d, 0x85, 0x66, 0x21, 0x39, 0x86, 0xaa, 0xdd, 0xa4,
	0x84, 0x49, 0x16, 0x1b, 0x51, 0xac, 0xe6, 0x06, 0x7a, 0x66, 0x11, 0xf2, 0x25, 0xd8, 0xc8, 0x9b,
	0xb3, 0x68, 0x86, 0xad, 0xdd, 0xb7, 0x32, 0x78, 0xc5, 0xdc, 0x78, 0x61, 0x2e, 0x10, 0x0a, 0x87,
	0x3e, 0x2a, 0x1d, 0x72, 0xa6, 0x43, 0xc1, 0xbd, 0x80, 0x29, 0x2f, 0x0a, 0xe3, 0x50, 0xb7, 0xca,
	0x6f, 0xc5, 0xf4, 0xde, 0xda, 0xe5, 0xc7, 0x4c, 0x7d, 0x6d, 0xae, 0x76, 0x7f, 0xdd, 0x86, 0xfa,
	0x13, 0x7e, 0x2e, 0x66, 0xdc, 0x37, 0xe3, 0x1d, 0x9a, 0x47, 0x80, 0x9c, 0x42, 0x3d, 0x95, 0xc4,
	0xf3, 0xb3, 0x15, 0xb7, 0x63, 0xae, 0x0e, 0x0e, 0x53, 0xb5, 0x37, 0xf6, 0x7f, 0x54, 0xa0, 0x35,
	0xb5, 0xf1, 0x24, 0xac, 0x73, 0x38, 0xe1, 0x9d, 0x63, 0x36, 0x38, 0x5c, 0x72, 0x9d, 0x23, 0x33,
	0xca, 0xa7, 0x60, 0xbb, 0xf7, 0x14, 0x72, 0x6d, 0xa5, 0xaa, 0x0e, 0xf6, 0xd3, 0xcb, 0x99, 0x15,
	0x46, 0x05, 0x5a, 0x4e, 0x32, 0x5b, 0x0c, 0xa1, 0xb1, 0xe6, 0xe3, 0x9f, 0xac, 0xb9, 0xad, 0x7c,
	0xd5, 0x41, 0x73, 0xd3, 0xa5, 0xa9, 0xf5, 0x47, 0x05, 0x5a, 0x5f, 0x6c, 0xae, 0xc3, 0x08, 0x88,
	0xab, 0x7c, 0xb6, 0x32, 0xad, 0xd5, 0xba, 0x3a, 0xb8, 0xb3, 0x5e, 0xfb, 0x9a, 0xa7, 0x47, 0x05,
	0xda, 0x50, 0xff, 0x32, 0xfa, 0x4b, 0x68, 0x4b, 0x0c, 0x42, 0xa5, 0x73, 0xcb, 0xf9, 0x73, 0xe5,
	0x69, 0xe1, 0x99, 0x92, 0xad, 0x3f, 0xaa, 0x83, 0xa3, 0x94, 0x91, 0xba, 0x73, 0xd6, 0x81, 0x8f,
	0x5e, 0x8c, 0xcf, 0x84, 0x69, 0x71, 0x54, 0xa0, 0x4d, 0xf9, 0x8f, 0xcc, 0x5c, 0xa5, 0x99, 0xd3,
	0xaa, 0x9b, 0x8d, 0xcf, 0x34, 0xeb, 0xfe, 0xb6, 0x05, 0xcd, 0xff, 0x66, 0x20, 0x77, 0xa1, 0x9c,
	0xbb, 0xdd, 0x68, 0x58, 0xa2, 0xbb, 0x13, 0xe7, 0xf2, 0xcf, 0xe1, 0x4e, 0x4a, 0x2e, 0x2f, 0x3d,
	0x29, 0x66, 0xa6, 0x4a, 0xc1, 0xd3, 0xda, 0xd2, 0xd5, 0x39, 0xc8, 0xd2, 0xd4, 0x66, 0x9f, 0x72,
	0xcb, 0x78, 0x1f, 0x1a, 0x13, 0xe4, 0x5a, 0xb2, 0xc8, 0x53, 0x93, 0x29, 0xfa, 0xb3, 0x28, 0x7f,
	0xe0, 0xea, 0x2e, 0x31, 0xce, 0x70, 0xc2, 0xe0, 0xc8, 0xf4, 0x9c, 0x96, 0xc0, 0x92, 0x44, 0x0a,
	0xb3, 0x7f, 0x2a, 0x0c, 0x38, 0xd3, 0x33, 0x89, 0x4e, 0x9e, 0x13, 0x37, 0xd6, 0x0c, 0x36, 0x3a,
	0x8d, 0x59, 0xa4, 0x1f, 0x72, 0x7f, 0xb8, 0x4c, 0x42, 0x79, 0x49, 0xef, 0xfa, 0x73, 0x65, 0x3b,
	0x7b, 0xe8, 0x38, 0xf2, 0xb3, 0xe4, 0x63, 0xa8, 0xe3, 0x8f, 0x38, 0xb1, 0x3b, 0x11, 0x33, 0xce,
	0x02, 0x94, 0x6e, 0x33, 0x6b, 0x19, 0xfe, 0x4d, 0x0a, 0x93, 0x0f, 0xe1, 0xb6, 0x55, 0x29, 0x3f,
	0x97, 0xee, 0xe8, 0x9e, 0x05, 0xdd, 0xa1, 0xee, 0x0f, 0xd0, 0x7e, 0x73, 0x21, 0xe4, 0x08, 0x2a,
	0xab, 0xea, 0xd3, 0x67, 0x72, 0x05, 0x10, 0x02, 0x25, 0xc5, 0x22, 0x6d, 0xe7, 0xb7, 0x47, 0xed,
	0x6f, 0xf3, 0x20, 0xa1, 0xbd, 0x6b, 0x87, 0x54, 0xa2, 0x2e, 0x3a, 0x1d, 0xbe, 0xba, 0xee, 0x14,
	0x5f, 0x5f, 0x77, 0x8a, 0x7f, 0x5d, 0x77, 0x8a, 0x3f, 0xdf, 0x74, 0x0a, 0xaf, 0x6f, 0x3a, 0x85,
	0x3f, 0x6e, 0x3a, 0x85, 0x97, 0xf7, 0x83, 0x50, 0x4f, 0x67, 0xe7, 0xbd, 0x89, 0x88, 0xfb, 0x0f,
	0x96, 0x66, 0xe8, 0xdf, 0xa2, 0x5e, 0x08, 0x79, 0xd1, 0x67, 0x46, 0x90, 0xfe, 0xb2, 0x6f, 0x3f,
	0xdb, 0xfa, 0x32, 0x41, 0x75, 0xbe, 0x63, 0x3f, 0xcb, 0x9f, 0xfd, 0x1d, 0x00, 0x00, 0xff, 0xff,
	0x12, 0x66, 0xac, 0xc4, 0xcb, 0x07, 0x00, 0x00,
}

func (m *StakerDeposited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakerDeposited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakerDeposited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPellEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Strategy) > 0 {
		i -= len(m.Strategy)
		copy(dAtA[i:], m.Strategy)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Strategy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakerDelegated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakerDelegated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakerDelegated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Withdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Withdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Withdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shares[iNdEx])
			copy(dAtA[i:], m.Shares[iNdEx])
			i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Shares[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Strategies) > 0 {
		for iNdEx := len(m.Strategies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Strategies[iNdEx])
			copy(dAtA[i:], m.Strategies[iNdEx])
			i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Strategies[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintPellEvent(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Withdrawer) > 0 {
		i -= len(m.Withdrawer)
		copy(dAtA[i:], m.Withdrawer)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Withdrawer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DelegatedTo) > 0 {
		i -= len(m.DelegatedTo)
		copy(dAtA[i:], m.DelegatedTo)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.DelegatedTo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawalQueued) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawalQueued) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawalQueued) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Withdrawal != nil {
		{
			size, err := m.Withdrawal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.WithdrawalRoot) > 0 {
		i -= len(m.WithdrawalRoot)
		copy(dAtA[i:], m.WithdrawalRoot)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.WithdrawalRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakerUndelegated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakerUndelegated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakerUndelegated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PellSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PellSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PellSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.DestinationGasLimit.Size()
		i -= size
		if _, err := m.DestinationGasLimit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPellEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.PellValue.Size()
		i -= size
		if _, err := m.PellValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPellEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.PellParams) > 0 {
		i -= len(m.PellParams)
		copy(dAtA[i:], m.PellParams)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.PellParams)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReceiverChainId != 0 {
		i = encodeVarintPellEvent(dAtA, i, uint64(m.ReceiverChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxOrigin) > 0 {
		i -= len(m.TxOrigin)
		copy(dAtA[i:], m.TxOrigin)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.TxOrigin)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InboundPellEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InboundPellEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PellData != nil {
		{
			size := m.PellData.Size()
			i -= size
			if _, err := m.PellData.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InboundPellEvent_StakerDeposited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_StakerDeposited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StakerDeposited != nil {
		{
			size, err := m.StakerDeposited.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InboundPellEvent_StakerDelegated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_StakerDelegated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StakerDelegated != nil {
		{
			size, err := m.StakerDelegated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *InboundPellEvent_PellSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_PellSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PellSent != nil {
		{
			size, err := m.PellSent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *InboundPellEvent_WithdrawalQueued) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_WithdrawalQueued) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WithdrawalQueued != nil {
		{
			size, err := m.WithdrawalQueued.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *InboundPellEvent_StakerUndelegated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_StakerUndelegated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StakerUndelegated != nil {
		{
			size, err := m.StakerUndelegated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *InboundPellEvent_RegisterChainDvsToPell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboundPellEvent_RegisterChainDvsToPell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegisterChainDvsToPell != nil {
		{
			size, err := m.RegisterChainDvsToPell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *RegisterChainDVSToPell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterChainDVSToPell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterChainDVSToPell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakeManager) > 0 {
		i -= len(m.StakeManager)
		copy(dAtA[i:], m.StakeManager)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.StakeManager)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EjectionManager) > 0 {
		i -= len(m.EjectionManager)
		copy(dAtA[i:], m.EjectionManager)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.EjectionManager)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DvsChainApproverSignature != nil {
		{
			size, err := m.DvsChainApproverSignature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPellEvent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CentralScheduler) > 0 {
		i -= len(m.CentralScheduler)
		copy(dAtA[i:], m.CentralScheduler)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.CentralScheduler)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegistryRouterOnPell) > 0 {
		i -= len(m.RegistryRouterOnPell)
		copy(dAtA[i:], m.RegistryRouterOnPell)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.RegistryRouterOnPell)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintPellEvent(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SignatureWithSaltAndExpiry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureWithSaltAndExpiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureWithSaltAndExpiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expiry != 0 {
		i = encodeVarintPellEvent(dAtA, i, uint64(m.Expiry))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPellEvent(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPellEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovPellEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StakerDeposited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = m.Shares.Size()
	n += 1 + l + sovPellEvent(uint64(l))
	return n
}

func (m *StakerDelegated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}

func (m *Withdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.DelegatedTo)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Withdrawer)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovPellEvent(uint64(m.StartTimestamp))
	}
	if len(m.Strategies) > 0 {
		for _, s := range m.Strategies {
			l = len(s)
			n += 1 + l + sovPellEvent(uint64(l))
		}
	}
	if len(m.Shares) > 0 {
		for _, s := range m.Shares {
			l = len(s)
			n += 1 + l + sovPellEvent(uint64(l))
		}
	}
	return n
}

func (m *WithdrawalQueued) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawalRoot)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	if m.Withdrawal != nil {
		l = m.Withdrawal.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}

func (m *StakerUndelegated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}

func (m *PellSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxOrigin)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	if m.ReceiverChainId != 0 {
		n += 1 + sovPellEvent(uint64(m.ReceiverChainId))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.PellParams)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = m.PellValue.Size()
	n += 1 + l + sovPellEvent(uint64(l))
	l = m.DestinationGasLimit.Size()
	n += 1 + l + sovPellEvent(uint64(l))
	return n
}

func (m *InboundPellEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PellData != nil {
		n += m.PellData.Size()
	}
	return n
}

func (m *InboundPellEvent_StakerDeposited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StakerDeposited != nil {
		l = m.StakerDeposited.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *InboundPellEvent_StakerDelegated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StakerDelegated != nil {
		l = m.StakerDelegated.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *InboundPellEvent_PellSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PellSent != nil {
		l = m.PellSent.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *InboundPellEvent_WithdrawalQueued) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithdrawalQueued != nil {
		l = m.WithdrawalQueued.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *InboundPellEvent_StakerUndelegated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StakerUndelegated != nil {
		l = m.StakerUndelegated.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *InboundPellEvent_RegisterChainDvsToPell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegisterChainDvsToPell != nil {
		l = m.RegisterChainDvsToPell.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}
func (m *RegisterChainDVSToPell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovPellEvent(uint64(m.ChainId))
	}
	l = len(m.RegistryRouterOnPell)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.CentralScheduler)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	if m.DvsChainApproverSignature != nil {
		l = m.DvsChainApproverSignature.Size()
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.EjectionManager)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.StakeManager)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	return n
}

func (m *SignatureWithSaltAndExpiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovPellEvent(uint64(l))
	}
	if m.Expiry != 0 {
		n += 1 + sovPellEvent(uint64(m.Expiry))
	}
	return n
}

func sovPellEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPellEvent(x uint64) (n int) {
	return sovPellEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StakerDeposited) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakerDeposited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakerDeposited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakerDelegated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakerDelegated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakerDelegated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Withdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Withdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Withdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatedTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatedTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Withdrawer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategies = append(m.Strategies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawalQueued) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawalQueued: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawalQueued: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawalRoot = append(m.WithdrawalRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawalRoot == nil {
				m.WithdrawalRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withdrawal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Withdrawal == nil {
				m.Withdrawal = &Withdrawal{}
			}
			if err := m.Withdrawal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakerUndelegated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakerUndelegated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakerUndelegated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PellSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PellSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PellSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxOrigin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverChainId", wireType)
			}
			m.ReceiverChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiverChainId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PellParams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PellParams = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PellValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PellValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationGasLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DestinationGasLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InboundPellEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InboundPellEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InboundPellEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerDeposited", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StakerDeposited{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_StakerDeposited{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerDelegated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StakerDelegated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_StakerDelegated{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PellSent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PellSent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_PellSent{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalQueued", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WithdrawalQueued{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_WithdrawalQueued{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerUndelegated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StakerUndelegated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_StakerUndelegated{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterChainDvsToPell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RegisterChainDVSToPell{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PellData = &InboundPellEvent_RegisterChainDvsToPell{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterChainDVSToPell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterChainDVSToPell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterChainDVSToPell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryRouterOnPell", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryRouterOnPell = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CentralScheduler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CentralScheduler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DvsChainApproverSignature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DvsChainApproverSignature == nil {
				m.DvsChainApproverSignature = &SignatureWithSaltAndExpiry{}
			}
			if err := m.DvsChainApproverSignature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EjectionManager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EjectionManager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeManager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakeManager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureWithSaltAndExpiry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureWithSaltAndExpiry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureWithSaltAndExpiry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPellEvent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPellEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiry", wireType)
			}
			m.Expiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPellEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPellEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPellEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPellEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPellEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPellEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPellEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPellEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPellEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPellEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPellEvent = fmt.Errorf("proto: unexpected end of group")
)
